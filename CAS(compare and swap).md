# CAS(compare and swap)

## 多线程三大特性

在程序中使用多线程的目的是什么？

> 1、提高效率，增加任务的吞吐量
> 2、提升CPU等资源的利用率，减少CPU的空转

多线程的应用在日常开发中很多，带来了很多的便利，但也有要注意问题，一般主要从这三个方面考虑

**一、原子性**

原子性是指**一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉**。

**二、可见性**

可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改。

**三、一致性**

有序性是指程序在执行的时候，程序的代码执行顺序和语句的顺序是一致的。那为什么会出现不一致的情况呢？这是由于重排序的缘故。

在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序；重排序不会影响单线程的执行结果，但是在并发情况下，可能会出现诡异的BUG。

## CAS

CAS 的意思是 compare and swap，比较并交换。cas的引入是为了解决java锁机制带来的性能问题。锁机制存在以下问题：

（1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。

（2）一个线程持有锁会导致其它所有需要此锁的线程挂起。

（3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。

解决线程安全问题volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。 独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。



### CAS原理流程图

CAS 操作包含三个操作数 —— 旧值、预期原值和新值。如果旧值还和预期原值的值是一样的，那么就将旧值更新成新值。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。



![image-20231024201630394](https://raw.githubusercontent.com/DecZeroTwo/blogimage/main/images/202310242016439.png)



### CAS引发的ABA问题

ABA问题是指在CAS操作时，其他线程将变量值A改为了B，但是又被改回了A，等到本线程使用期望值A与当前变量进行比较时，发现变量A没有变，于是CAS就将A值进行了交换操作，但是实际上该值已经被其他线程改变过，这与乐观锁的设计思想不符合。

java并发包中提供了一个带有标记的原子引用类AtomicStampedReference，它可以通过控制变量值的版本号来保证CAS的正确性，比较两个值的版本号是否一致，如果一致，才会设置新值。

### CAS导致自旋消耗

Atomic类设置值的时候会进入一个无限循环，只要不成功，就会不停的循环再次尝试。在高并发时，如果大量线程频繁修改同一个值，可能会导致大量线程执行compareAndSet()方法时需要循环N次才能设置成功，即大量线程执行一个重复的空循环（自旋），造成大量开销。



### CAS只能单变量

Java中的CAS操作只是对CPU的cmpxchgq指令的一层封装。它的功能就是一次只原子地修改一个变量。

cmpxchgq的作用将RAX寄存器中的值与首操作数（目的操作数）比较，如果相等，第2操作数（源操作数）的值装载到首操作数，zf(Zero Flag)置1。如果不等， 首操作数的值装载到RAX寄存器并将zf清0。

CAS的原子操作只能针对一个共享变量，假如需要针对多个变量进行原子操作也是可以解决的。

**方法：**CAS操作是针对一个变量的，如果对多个变量操作，1. 可以加锁来解决。2 .封装成对象类解决。



## 参考

1.[https://cloud.tencent.com/developer/article/1459575](https://cloud.tencent.com/developer/article/1459575)
2.[https://www.zhihu.com/question/266359785](https://www.zhihu.com/question/266359785)