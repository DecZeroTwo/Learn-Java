# RPC和http的区别

## RPC

**RPC（即Remote Procedure Call，远程过程调用）和HTTP（HyperText Transfer Protocol，超文本传输协议）**，两者前者是一种方法，后者则是一种协议。两者都常用于实现服务，在这个层面最本质的区别是RPC服务主要工作在TCP协议之上（也可以在HTTP协议），而HTTP服务工作在HTTP协议之上。由于HTTP协议基于TCP协议，所以RPC服务天然比HTTP更轻量，效率更胜一筹。

两者都是基于网络实现的，从这一点上，都是基于**Client/Server架构**。

### RPC（Remote Procedure Call）服务

RPC服务基本架构包含了四个核心的组件，分别是`Client`,`Server`,`Clent Stub`以及`Server Stub`。



![img](https://raw.githubusercontent.com/DecZeroTwo/blogimage/main/images/202311251807345.jpeg)



 **Client （客户端）**：服务调用方。 **Server（服务端）**：服务提供方。 **Client Stub（客户端存根）**：存放服务端的地址消息，负责将客户端的请求参数打包成网络消息，然后通过网络发送给服务提供方。 **Server Stub（服务端存根）**：接收客户端发送的消息，再将客户端请求参数打包成网络消息，然后通过网络远程发送给服务方。

RPC效率优势明显，在实际开发中，客户端和服务端在技术方案中约定客户端的调用参数和服务端的返回参数之后就可以各自开发，任何客户端只要按照接口定义的规范发送入参都可以调用该RPC服务，服务端也能按接口定义的规范出参返回计算结果。这样既实现了客户端和服务端之间的解耦，也使得RPC接口可以在多个项目中重复利用。

RPC调用分为同步方式和异步方式。同步调用即客户端等待调用完成并返回结果；异步调用即客户端不等待调用执行完成返回结果，变成单向调用或者通过回调函数等待接收到返回结果的通知。



### 流行的RPC框架

>  目前流行的RPC框架有很多，下面介绍常见的三种。

1. `gRPC`：gRPC是Google公布的开源项目，基于HTTP2.0协议，并支持常见的众多编程语言。HTTP 2.0协议是基于二进制的HTTP协议的升级版本，gRPC底层使用了Netty框架。
2. `Thrift`：Thrift是Facebook的一个开源项目，主要是一个跨语言的服务开发框架。它有一个代码生成器来对它所定义的IDL文件自动生成服务代码框架。Thrift对于底层的RPC通讯都是透明的，用户只需要对其进行二次开发即可，省去了一系列重复的前置基础开发工作。
3. `Dubbo`：Dubbo是阿里集团开源的一个极为出名的RPC框架，在很多互联网公司和企业应用中广泛使用。协议和序列化框架都可以插拔是及其鲜明的特色。



## HTTP

#### HTTP服务

>  通过HTTP URL调用的服务，浏览器访问本质上也算HTTP服务，不同的是需要客户端浏览器渲染服务端返回的结果。

HTTP服务开发即开发ERESTful风格的服务接口。在接口不多、系统之间交互较少的情况下，是一种信息传递的常用通信手段。HTTP接口的优点是简单、直接、开发方便，利用现成的HTTP协议进行传输。在服务开发的时候，约定一个接口文档，严格定义输入和输出，明确每一个接口的请求方法和需要的请求参数及其格式。



## 



## RPC接口和HTTP接口的区别与联系

**RPC接口**即相当于调用本地接口一样调用远程服务的接口；**HTTP接口**是基于http协议的post接口和get接口（等等，2.0版本协议子支持更多）。



|          | RPC                                                          | HTTP                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 传输协议 | 可以基于TCP协议，也可以基于HTTP协议。                        | 基于HTTP协议。                                               |
| 传输效率 | 使用自定义的TCP协议，可以让请求报文体积更小，或者使用HTTP2.0协议，也可以很好地减少报文体积，提高传输效率。 | 如果时基于HTTP1.1的协议，请求中会包含很多无用的内容；如果是基于HTTP2.0，那么简单地封装一下还是可以作为一个RPC使用的，这时标准RPC框架更多是服务治理。 |
| 性能消耗 | 可以基于thrift实现高效的二进制传输                           | 大部分是通过json实现的，字节大小和序列化耗时都比thrift要更消耗性能 |
| 负载均衡 | 基本都自带了负载均衡策略                                     | 需要配置Nginx，HAProxy实现                                   |
| 服务治理 | 能做到自动通知，不影响上游                                   | 需要事先通知，修改Nginx/HAProxy配置                          |

两者有不同的使用场景：

- 如果对**效率**要求更高，并且开发过程使用**统一的技术栈**，那么RPC还是不错的
- 如果需要更加**灵活**，**跨语言**、**跨平台**，显然HTTP更合适



## 为什么要使用自定义 tcp 协议的 rpc 做后端进程通信？

通用定义的http1.1协议的tcp报文包含太多废信息，一个POST协议的格式大致如下

```http
HTTP/1.0 200 OK 
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

<html>
  <body>Hello World</body>
</html>
```

即使编码协议也就是 body 是使用二进制编码协议，报文元数据也就是header头的键值对却使用了文本编码，非常占字节数。如上图所使用的报文中有效字节数仅仅占约 30%，也就是70%的时间用于传输元数据废编码。当然实际情况下报文内容可能会比这个长，但是报头所占的比例也是非常可观的。

这也就是为什么后端进程间通常会采用 自定义tcp协议 的 rpc 来进行通信的原因。



**不单效率那么简单**

　　所谓的效率优势是针对 http1.1协议 来讲的，http2.0协议 已经优化编码效率问题，像 grpc 这种 rpc 库使用的就是 http2.0协议。

　　简单来说成熟的 rpc库相对 http容器，更多的是封装了 “服务发现”，"负载均衡"，“熔断降级” 一类面向服务的高级特性。
